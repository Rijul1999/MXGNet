import os
import time
import matplotlib
matplotlib.use('Agg')
matplotlib.rcParams['figure.figsize'] = 1280,1280
import numpy as np
import math
import torch.optim as optim
from torchvision import datasets,transforms
import torch.utils
from .PGM_models import Model
from torch.utils.data import Dataset, DataLoader
import torch.nn.utils
import matplotlib.pyplot as plt
import itertools
#from load_data_merged import PGMDataset 
from data_utility_8s import dataset,ToTensor


def test(model,testloader,validloader,args):

    for epoch in range(1):
        if args.valid_result:
            total_correct = 0.0
            for (data,label,meta_target) in validloader:
                data = data.view(-1,16,image_h,image_w)
                label = label.view(-1)
                meta_target = meta_target.view(-1,12)
                data = data.to(device)
                label = label.to(device)
                meta_target = meta_target.to(device)
                _,score_vec = model(data,label,meta_target)
                _,pred = torch.max(score_vec,1)
                c = (pred == label).squeeze()  
                total_correct += torch.sum(c).item()
            accuracy = total_correct/(validData.__len__()*8)
            print('Validation Accuracy:',accuracy)
      
        total_correct = 0.0
        for (data,label,meta_target) in testloader:
            data = data.view(-1,16,image_h,image_w)
            label = label.view(-1)
            meta_target = meta_target.view(-1,12)
            data = data.to(device)
            label = label.to(device)
            meta_target = meta_target.to(device)
            _,score_vec = model(data,label,meta_target)
            _,pred = torch.max(score_vec,1)
            c = (pred == label).squeeze()                
            meta_target_np = meta_target.cpu().numpy()   
            total_correct += torch.sum(c).item()
        accuracy = total_correct/(testData.__len__()*8)
        print('Test Accuracy:',accuracy)


def main():
    parser = argparse.ArgumentParser(description='PyTorch MNIST Example')
    parser.add_argument('data-path', metavar='DIR',
                        help='path to dataset')
    parser.add_argument('--batch-size', type=int, default=16, metavar='N',
                        help='input batch size for training (default: 16)')
    parser.add_argument('--image-size', type=float, default=80, metavar='IMSIZE',
                        help='input image size (default: 80)')
    parser.add_argument('--no-cuda', action='store_true', default=False,
                        help='disables CUDA training')
    parser.add_argument('--multi-gpu', action='store_true', default=False,
                        help='parallel training on multiple GPUs')
    parser.add_argument('--valid_result', action='store_true', default=False,
                        help='compute results on validation dataset')
    parser.add_argument('--seed', type=int, default=1, metavar='S',
                        help='random seed (default: 1)')
    parser.add_argument('--save-model', action='store_true', default=False,
                        help='For Saving the current Model')
    parser.add_argument('--model-save-path', default='', type=str, metavar='PATH'
                        help='For Saving the current Model')
    parser.add_argument('--resume', default='', type=str, metavar='PATH',
                        help='path to latest checkpoint (default: none)')
    args = parser.parse_args()

    model_save_name = 'PGM_best.tar'
    optimizer_save_name = 'PGM_best_opt.tar'
    torch.set_default_tensor_type('torch.FloatTensor')

    device = torch.device("cuda" if cuda else "cpu")

    test = dataset(args.data_path, "test", args.image_size, transform=transforms.Compose([ToTensor()]))
    valid = dataset(args.data_path, "val", args.image_size, transform=transforms.Compose([ToTensor()]))

    testloader = DataLoader(test, batch_size=args.batch_size, num_workers=8)
    validloader = DataLoader(valid, batch_size=args.batch_size, num_workers=8)

    model = Model(args.image_size,args.image_size)



    if not args.no_cuda:
        model.cuda()


    if torch.cuda.device_count() > 1:
        print("Let's use", torch.cuda.device_count(), "GPUs!")
        model = torch.nn.DataParallel(model)

    if args.resume:
        model.load_state_dict(torch.load(os.path.join(args.resume,model_save_name )))
        optimizer.load_state_dict(torch.load(os.path.join(args.resume,optimizer_save_name )))

    test(model,testloader,validloader,args)

if __name__ == '__main__':
    main()
